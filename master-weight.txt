import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Item, WeightLog } from '@/types';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { NumberInput } from '@/components/ui/number-input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { ChartContainer, ChartTooltip, ChartTooltipContent, type ChartConfig } from '@/components/ui/chart';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, ReferenceLine } from 'recharts';
import { format, differenceInHours } from 'date-fns';
import { fr } from 'date-fns/locale';
import { TrendingDown, Plus, X, ChevronDown, Save } from 'lucide-react';

interface WeightTrackingProps {
    item: Item;
}

export function WeightTracking({ item }: WeightTrackingProps) {
    const [logs, setLogs] = useState<WeightLog[]>([]);
    const [loading, setLoading] = useState(false);

    // State pour les nouvelles pes√©es
    interface NewLogEntry {
        weight: number | undefined;
        date: Date;
        time: string;
        isCalendarOpen: boolean;
    }
    const [newLogs, setNewLogs] = useState<NewLogEntry[]>([]);

    const targetWeight = item.target_weight || 0;
    const initialWeight = item.initial_weight || 0;

    useEffect(() => {
        loadLogs();
    }, [item.id]);

    async function loadLogs() {
        const { data, error } = await supabase
            .from('weight_logs')
            .select('*')
            .eq('item_id', item.id)
            .order('date', { ascending: true });

        if (error) {
            console.error('Error loading weight logs:', error);
            return;
        }

        setLogs(data || []);
    }

    function addNewLogRow() {
        const now = new Date();
        setNewLogs([...newLogs, { 
            weight: undefined, 
            date: now,
            time: format(now, 'HH:mm'),
            isCalendarOpen: false
        }]);
    }

    function updateNewLog<K extends keyof NewLogEntry>(index: number, field: K, value: NewLogEntry[K]) {
        setNewLogs(prev => prev.map((log, i) => 
            i === index ? { ...log, [field]: value } : log
        ));
    }

    function removeNewLog(index: number) {
        setNewLogs(newLogs.filter((_, i) => i !== index));
    }

    async function saveNewLogs() {
        const validLogs = newLogs.filter(log => log.weight && log.weight > 0);
        if (validLogs.length === 0) return;

        setLoading(true);

        const logsToInsert = validLogs.map(log => {
            // Combiner date et time
            const [hours, minutes] = log.time.split(':').map(Number);
            const dateTime = new Date(log.date);
            dateTime.setHours(hours, minutes, 0, 0);
            
            return {
                item_id: item.id,
                weight: log.weight,
                date: dateTime.toISOString(),
            };
        });

        const { error } = await supabase
            .from('weight_logs')
            .insert(logsToInsert);

        if (error) {
            console.error('Error adding weight logs:', error);
            setLoading(false);
            return;
        }

        setNewLogs([]);
        setLoading(false);
        await loadLogs();
    }

    async function deleteLog(logId: number) {
        const { error } = await supabase
            .from('weight_logs')
            .delete()
            .eq('id', logId);

        if (error) {
            console.error('Error deleting weight log:', error);
            return;
        }

        await loadLogs();
    }

    // Calculs pour l'affichage
    const currentWeight = logs.length > 0 ? logs[logs.length - 1].weight : initialWeight;
    const weightLoss = initialWeight > 0 
        ? ((initialWeight - currentWeight) / initialWeight * 100).toFixed(1) 
        : '0';
    const targetLoss = initialWeight > 0 && targetWeight > 0
        ? ((initialWeight - targetWeight) / initialWeight * 100).toFixed(1)
        : '0';
    const isTargetReached = currentWeight > 0 && targetWeight > 0 && currentWeight <= targetWeight;

    // Pr√©paration des donn√©es du graphique
    const chartData = prepareChartData();

    function prepareChartData() {
        // Utiliser des timestamps pour avoir un axe X coh√©rent
        const data: { timestamp: number; date: string; fullDate: string; poids: number | null; projection: number | null }[] = [];
        
        const startDate = new Date(item.created_at);

        // Point initial (date de cr√©ation avec poids initial)
        if (initialWeight > 0) {
            data.push({
                timestamp: startDate.getTime(),
                date: format(startDate, 'dd/MM', { locale: fr }),
                fullDate: format(startDate, 'PPP', { locale: fr }),
                poids: initialWeight,
                projection: null,
            });
        }

        // Points des pes√©es
        logs.forEach(log => {
            const logDate = new Date(log.date);
            data.push({
                timestamp: logDate.getTime(),
                date: format(logDate, 'dd/MM', { locale: fr }),
                fullDate: format(logDate, 'PPP', { locale: fr }),
                poids: log.weight,
                projection: null,
            });
        });

        // Projection si on n'a pas atteint le poids cible
        if (!isTargetReached && targetWeight > 0 && data.length >= 2) {
            // Calculer la perte moyenne par jour entre toutes les pes√©es cons√©cutives
            // On utilise le poids initial + toutes les pes√©es pour avoir plus de donn√©es
            const allWeights: { date: Date; weight: number }[] = [];
            
            // Ajouter le poids initial
            if (initialWeight > 0) {
                allWeights.push({ date: new Date(item.created_at), weight: initialWeight });
            }
            
            // Ajouter toutes les pes√©es
            logs.forEach(log => {
                allWeights.push({ date: new Date(log.date), weight: log.weight });
            });

            if (allWeights.length >= 2) {
                // Calculer la perte horaire moyenne entre chaque paire de points cons√©cutifs
                let totalHourlyLosses = 0;
                let validPairs = 0;

                for (let i = 1; i < allWeights.length; i++) {
                    const hoursBetween = differenceInHours(allWeights[i].date, allWeights[i - 1].date);
                    if (hoursBetween > 0) {
                        const weightLoss = allWeights[i - 1].weight - allWeights[i].weight;
                        const hourlyLoss = weightLoss / hoursBetween;
                        totalHourlyLosses += hourlyLoss;
                        validPairs++;
                    }
                }

                const avgHourlyLoss = validPairs > 0 ? totalHourlyLosses / validPairs : 0;

                if (avgHourlyLoss > 0) {
                    const lastWeight = allWeights[allWeights.length - 1];
                    const remainingWeight = lastWeight.weight - targetWeight;
                    const hoursToTarget = Math.ceil(remainingWeight / avgHourlyLoss);

                    // Ajouter le dernier point r√©el aussi dans projection pour continuit√©
                    data[data.length - 1].projection = lastWeight.weight;

                    // Ajouter le point de projection final
                    const projectedDate = new Date(lastWeight.date);
                    projectedDate.setTime(projectedDate.getTime() + hoursToTarget * 60 * 60 * 1000);
                    
                    data.push({
                        timestamp: projectedDate.getTime(),
                        date: format(projectedDate, 'dd/MM', { locale: fr }),
                        fullDate: format(projectedDate, 'PPP', { locale: fr }) + ' (projection)',
                        poids: null,
                        projection: targetWeight,
                    });
                }
            }
        }

        return data;
    }

    // Utiliser les timestamps des points de donn√©es comme ticks
    const dataTicks = chartData.map(d => d.timestamp);

    // R√©cup√©rer la date de fin pr√©visionnelle (dernier point de projection)
    const projectionPoint = chartData.find(d => d.projection !== null && d.poids === null);
    const projectedEndDate = projectionPoint ? new Date(projectionPoint.timestamp) : null;

    // Calculer le domaine Y avec des graduations tous les 40g et une marge
    const allWeightsInChart = chartData.flatMap(d => [d.poids, d.projection]).filter((w): w is number => w !== null);
    const minWeight = Math.min(...allWeightsInChart, targetWeight || Infinity);
    const maxWeight = Math.max(...allWeightsInChart);
    // Arrondir aux 40g inf√©rieurs - 40 pour la marge basse
    const yDomainMin = Math.floor(minWeight / 40) * 40 - 40;
    // Arrondir aux 40g sup√©rieurs + 40 pour la marge haute
    const yDomainMax = Math.ceil(maxWeight / 40) * 40 + 40;
    // G√©n√©rer les ticks tous les 40g
    const yTicks: number[] = [];
    for (let y = yDomainMin; y <= yDomainMax; y += 40) {
        yTicks.push(y);
    }

    // Formater le tick de l'axe X
    const formatXAxis = (timestamp: number) => {
        return format(new Date(timestamp), 'dd/MM', { locale: fr });
    };

    // Configuration du graphique shadcn
    const chartConfig = {
        poids: {
            label: 'Poids',
            color: 'hsl(var(--primary))',
        },
        projection: {
            label: 'Projection',
            color: 'hsl(var(--primary))',
        },
    } satisfies ChartConfig;

    return (
        <div className="space-y-5 overflow-hidden w-full">
            {/* Section 1: R√©sum√© des poids */}
            <div className="space-y-1.5">
                <h3 className="text-md font-medium">R√©sum√©</h3>
                <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
                    <div className="bg-secondary p-3 rounded-md min-w-0">
                        <p className="text-sm text-muted-foreground leading-tight">Poids initial</p>
                        <p className="text-lg font-bold">{initialWeight}g</p>
                    </div>

                    <div className={`p-3 rounded-md border min-w-0 ${isTargetReached ? 'bg-green-500/10 border-green-500/20' : 'bg-orange-500/10 border-orange-500/20'}`}>
                        <p className={`text-sm leading-tight ${isTargetReached ? 'text-green-600 dark:text-green-400' : 'text-orange-600 dark:text-orange-400'}`}>Derni√®re mesure</p>
                        <p className="text-lg font-bold">{currentWeight}g</p>
                    </div>

                    <div className="bg-secondary p-3 rounded-md min-w-0">
                        <p className="text-sm text-muted-foreground leading-tight">Poids cible</p>
                        <p className="text-lg font-bold">{targetWeight}g <span className="text-sm font-normal text-muted-foreground">(-{targetLoss}%)</span></p>
                    </div>

                    <div className={`p-3 rounded-md min-w-0 ${isTargetReached ? 'bg-green-500/10' : 'bg-secondary'}`}>
                        <p className="text-sm text-muted-foreground leading-tight flex items-center gap-0.5">
                            <TrendingDown className="h-3 w-3 shrink-0" />
                            Perte actuelle
                        </p>
                        <p className={`text-lg font-bold ${isTargetReached ? 'text-green-600' : ''}`}>
                            {weightLoss}%
                        </p>
                    </div>
                </div>
            </div>

            {/* Section 2: Pes√©es */}
            <div className="space-y-2 border-t pt-2">
                <div className="flex items-center justify-between">
                    <h3 className="text-md font-medium">Pes√©es</h3>
                    <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        className="h-7 text-sm"
                        onClick={addNewLogRow}
                    >
                        <Plus className="h-3 w-3" />
                        Ajouter
                    </Button>
                </div>

                {/* Pes√©e initiale (non supprimable) */}
                {initialWeight > 0 && (
                    <div className="flex items-center gap-3 bg-muted/50 p-2 rounded-md">
                        <span className="flex-1 text-muted-foreground text-sm min-w-0">
                            {format(new Date(item.created_at), "d MMMM yyyy '√†' HH:mm", { locale: fr })} (pes√©e initiale)
                        </span>
                        <span className="font-medium text-sm shrink-0">{initialWeight}g</span>
                        <div className="h-4 w-4 shrink-0" />
                    </div>
                )}

                {/* Pes√©es existantes */}
                {logs.length > 0 && (
                    <div className="space-y-2">
                        {logs.map((log) => (
                            <div key={log.id} className="flex items-center gap-3 bg-muted/50 p-2 rounded-md">
                                <span className="flex-1 text-muted-foreground text-sm min-w-0">
                                    {format(new Date(log.date), "d MMMM yyyy '√†' HH:mm", { locale: fr })}
                                </span>
                                <span className="font-medium text-sm shrink-0">{log.weight}g</span>
                                <Button
                                    type="button"
                                    variant="ghost"
                                    size="icon"
                                    className="h-4 w-4 shrink-0 text-muted-foreground hover:text-destructive"
                                    onClick={() => deleteLog(log.id)}
                                >
                                    <X className="h-2.5 w-2.5" />
                                </Button>
                            </div>
                        ))}
                    </div>
                )}

                {/* Nouvelles pes√©es √† ajouter - Pattern calendar-24 shadcn */}
                {newLogs.length > 0 && (
                    <div className="space-y-2">
                        {newLogs.map((log, index) => (
                            <div key={index} className="flex flex-wrap items-center gap-2 bg-muted/30 p-2 rounded-lg">
                                {/* Date Picker */}
                                <Popover 
                                    open={log.isCalendarOpen} 
                                    onOpenChange={(open) => updateNewLog(index, 'isCalendarOpen', open)}
                                >
                                    <PopoverTrigger asChild>
                                        <Button
                                            variant="outline"
                                            className="w-[90px] justify-between font-normal text-xs px-2"
                                        >
                                            {format(log.date, 'dd/MM/yy', { locale: fr })}
                                            <ChevronDown className="h-3 w-3 opacity-50" />
                                        </Button>
                                    </PopoverTrigger>
                                    <PopoverContent className="w-auto overflow-hidden p-0" align="start">
                                        <Calendar
                                            mode="single"
                                            selected={log.date}
                                            captionLayout="dropdown"
                                            onSelect={(date) => {
                                                if (date) {
                                                    updateNewLog(index, 'date', date);
                                                    updateNewLog(index, 'isCalendarOpen', false);
                                                }
                                            }}
                                            locale={fr}
                                        />
                                    </PopoverContent>
                                </Popover>
                                
                                {/* Time Picker */}
                                <Input
                                    type="time"
                                    value={log.time}
                                    onChange={(e) => updateNewLog(index, 'time', e.target.value)}
                                    className="w-[70px] bg-background appearance-none [&::-webkit-calendar-picker-indicator]:hidden [&::-webkit-calendar-picker-indicator]:appearance-none text-xs px-2"
                                />
                                
                                {/* Weight Input */}
                                <NumberInput
                                    value={log.weight}
                                    onChange={(value) => updateNewLog(index, 'weight', value)}
                                    minValue={0}
                                    step={5}
                                    suffix="g"
                                    className="w-[70px] flex-1 min-w-[60px]"
                                    placeholder="Poids"
                                />
                                
                                <Button
                                    type="button"
                                    variant="ghost"
                                    size="icon"
                                    onClick={() => removeNewLog(index)}
                                    className="shrink-0 h-8 w-8 text-muted-foreground hover:text-destructive"
                                >
                                    <X className="h-4 w-4" />
                                </Button>
                            </div>
                        ))}
                        <div className="flex justify-center pt-2">
                            <Button
                                onClick={saveNewLogs}
                                disabled={loading || newLogs.every(log => !log.weight)}
                                className="bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white"
                            >
                                <Save className="mr-2 h-4 w-4" />
                                Enregistrer les pes√©es
                            </Button>
                        </div>
                    </div>
                )}
            </div>

            {/* Section 3: Graphique */}
            {(logs.length > 0 || initialWeight > 0) && (
                <div className="space-y-1.5 border-t pt-2">
                    <h3 className="text-md font-medium">√âvolution du poids</h3>
                    <ChartContainer config={chartConfig} className="h-[220px] w-full">
                        <LineChart data={chartData} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
                            <CartesianGrid vertical={false} />
                            <XAxis 
                                dataKey="timestamp"
                                type="number"
                                domain={['dataMin', 'dataMax']}
                                ticks={dataTicks}
                                tickFormatter={formatXAxis}
                                tickLine={false}
                                axisLine={false}
                                tickMargin={4}
                                padding={{ left: 20, right: 5 }}
                                scale="time"
                                tick={{ fontSize: 12 }}
                            />
                            <YAxis 
                                tickLine={false}
                                axisLine={false}
                                tickMargin={4}
                                domain={[yDomainMin, yDomainMax]}
                                ticks={yTicks}
                                interval={0}
                                tick={{ fontSize: 12 }}
                                width={35}
                            />
                            <ChartTooltip
                                cursor={false}
                                content={
                                    <ChartTooltipContent
                                        formatter={(value, name, item) => {
                                            const dataPoint = item.payload;
                                            // Si c'est la projection et qu'il y a aussi un poids r√©el, ne pas afficher la projection
                                            if (name === 'projection' && dataPoint.poids !== null) {
                                                return null;
                                            }
                                            return (
                                                <>
                                                    <div
                                                        className="h-2.5 w-2.5 shrink-0 rounded-[2px] bg-[--color-poids]"
                                                    />
                                                    <span className="text-muted-foreground">
                                                        Poids
                                                    </span>
                                                    <span className="font-mono font-medium text-foreground">
                                                        {value}g
                                                    </span>
                                                </>
                                            );
                                        }}
                                        labelFormatter={(_, payload) => {
                                            if (payload && payload[0]) {
                                                return payload[0].payload.fullDate;
                                            }
                                            return '';
                                        }}
                                    />
                                }
                            />
                            {targetWeight > 0 && (
                                <ReferenceLine
                                    y={targetWeight}
                                    stroke="#22c55e"
                                    strokeDasharray="5 5"
                                    label={{ value: 'Cible', position: 'right', fontSize: 11, fill: '#22c55e' }}
                                />
                            )}
                            {/* Ligne r√©elle */}
                            <Line
                                type="natural"
                                dataKey="poids"
                                stroke="var(--color-poids)"
                                strokeWidth={2}
                                dot={{ fill: 'var(--color-poids)' }}
                                activeDot={{ r: 6 }}
                                connectNulls={false}
                                label={(props: any) => {
                                    const { x, y, value } = props;
                                    // Return an SVG element (never null) ‚Äî use a lightweight <g/> when there's nothing to render
                                    if (value == null) return <g />;
                                    return (
                                        <text
                                            x={x}
                                            y={y - 8}
                                            textAnchor="middle"
                                            fill="var(--color-poids)"
                                            fontSize={12}
                                            fontWeight={500}
                                        >
                                            {value}g
                                        </text>
                                    );
                                }}
                            />
                            {/* Ligne de projection */}
                            <Line
                                type="natural"
                                dataKey="projection"
                                stroke="var(--color-projection)"
                                strokeWidth={2}
                                strokeDasharray="5 5"
                                dot={{ fill: 'var(--color-projection)' }}
                                activeDot={{ r: 6 }}
                                connectNulls={false}
                            />
                        </LineChart>
                    </ChartContainer>
                    {projectedEndDate && !isTargetReached && (
                        <div className="bg-orange-500/10 border border-orange-500/20 p-1.5 rounded-md text-center">
                            <p className="text-sm leading-tight">
                                <span className="text-muted-foreground">Fin d'affinage pr√©vue : </span>
                                <span className="font-medium text-orange-600 dark:text-orange-400">
                                    {format(projectedEndDate, 'd MMM yyyy', { locale: fr })}
                                </span>
                            </p>
                        </div>
                    )}
                    {isTargetReached && (
                        <div className="bg-green-500/10 border border-green-500/20 p-1.5 rounded-md text-center">
                            <p className="text-sm leading-tight font-medium text-green-600 dark:text-green-400">
                                üéâ Objectif atteint ! Le poids cible a √©t√© atteint.
                            </p>
                        </div>
                    )}
                </div>
            )}
        </div>
    );
}
